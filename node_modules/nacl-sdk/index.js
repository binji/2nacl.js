// Copyright 2014 Ben Smith. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var child_process = require('child_process'),
    fs = require('fs'),
    mkdirp = require('mkdirp'),
    path = require('path'),
    execFile = child_process.execFile,

    defaultArches = ['x86_32', 'x86_64', 'arm'],

    toolsHash = {},

    NACL_SDK_ROOT = process.env.NACL_SDK_ROOT,
    sdkToolsDir,
    sdkIncludeDir,
    sdkLibDir,
    naclConfigPath,
    selLdrPath,
    createNmfPath;

if (!NACL_SDK_ROOT) {
  throw new Error('NACL_SDK_ROOT environment variable not set.');
}

sdkToolsDir = path.resolve(NACL_SDK_ROOT, 'tools'),
sdkIncludeDir = path.join(NACL_SDK_ROOT, 'include'),
sdkLibDir = path.join(NACL_SDK_ROOT, 'lib'),
naclConfigPath = path.join(sdkToolsDir, 'nacl_config.py'),
selLdrPath = path.join(NACL_SDK_ROOT, 'tools', 'sel_ldr.py'),
createNmfPath = path.join(NACL_SDK_ROOT, 'tools', 'create_nmf.py');


function prefixAll(prefix, a) {
  return a.map(function(el) { return prefix + el; });
}

function maybeConcatWithPrefix(args, prefix, a) {
  if (a) {
    if (!Array.isArray(a)) {
      throw new Error('Expected a to be an Array.');
    }

    return args.concat(prefixAll(prefix, a));
  }

  return args;
}

function clone(obj) {
  var result,
      i,
      clazz = Object.prototype.toString.call(obj);

  switch (clazz) {
    case '[Object Object]':
      result = {};
      for (i in obj) {
        result[i] = clone(obj[i]);
      }
      return result;

    case '[Object Array]':
      result = [];
      for (i = 0; i < obj.length; ++i) {
        result[i] = clone(obj[i]);
      }
      break;

    default:
      return obj;
  }
}

function extendWith(to, from, name) {
  to[name] = to[name] || from[name];
}

function extendWithAll(to, from, names) {
  var i;
  for (i = 0; i < names.length; ++i) {
    extendWith(to, from, names[i]);
  }
}

function changeext(p, newExt) {
  return splitext(p)[0] + newExt;
}


function splitext(p) {
  var ext = path.extname(p),
      i = p.lastIndexOf(ext);
  return [p.slice(0, i), ext];
}

function getToolPath(tool, opts, callback) {
  var args,
      key = [tool, opts.toolchain, opts.arch].join('-');

  if (toolsHash[key]) {
    process.nextTick(function() {
      callback(null, toolsHash[key]);
    });
    return;
  }

  args = [naclConfigPath, '-t', opts.toolchain];
  if (opts.toolchain !== 'pnacl') {
    args.push('-a');
    args.push(opts.arch);
  }

  args.push('--tool');
  args.push(tool);

  execFile('python', args, function(error, stdout, stderr) {
    if (error) {
      return callback(error);
    }

    var result = stdout.trim();
    toolsHash[key] = result;
    callback(null, result);
  });
}

function runTool(tool, outfile, args, opts, execOpts, callback) {
  getToolPath(tool, opts, function(error, tool) {
    if (error) {
      return callback(error);
    }

    mkdirp(path.dirname(outfile), function(error) {
      if (error) {
        return callback(error);
      }

      execFile(tool, args, execOpts, function(error) {
        if (error) {
          return callback(error);
        }

        callback(null, outfile);
      });
    });
  });
}

function compile(infiles, outfile, opts, callback) {
  var getDefaultIncludeDirs = function() {
        return [sdkIncludeDir, path.join(sdkIncludeDir, opts.toolchain)];
      },

      getDefaultLibDirs = function() {
        if (opts.toolchain === 'pnacl') {
          return [path.join(sdkLibDir, opts.toolchain, opts.config)];
        } else {
          return [path.join(sdkLibDir, opts.toolchain + '_' + opts.arch,
                  opts.config)];
        }
      },

      args = [],
      lastExt = null,
      i,
      ext;

  if (!opts.toolchain) {
    throw new Error('opts.toolchain must be set.');
  }

  if (!opts.config) {
    throw new Error('opts.config must be set.');
  }

  if (opts.toolchain !== 'pnacl' && !opts.arch) {
    throw new Error('opts.arch must be set.');
  }

  opts = clone(opts) || {};

  for (i = 0; i < infiles.length; ++i) {
    ext = path.extname(infiles[i]);
    if (ext !== lastExt) {
      if (ext === '.c') {
        args.push('-x');
        args.push('c');
      } else if (ext === '.cc') {
        args.push('-x');
        args.push('c++');
      } else {
        throw new Error('Unknown extension ' + ext);
      }
    }

    args.push(infiles[i]);
  };
  args.push('-o');
  args.push(outfile);

  // Add default include directories.
  opts.includeDirs = clone(opts.includeDirs) || [];
  args = maybeConcatWithPrefix(args, '-I', getDefaultIncludeDirs());
  args = maybeConcatWithPrefix(args, '-L', getDefaultLibDirs());

  args = maybeConcatWithPrefix(args, '-D', opts.defines);
  args = maybeConcatWithPrefix(args, '-I', opts.includeDirs);
  args = maybeConcatWithPrefix(args, '-L', opts.libDirs);
  args = maybeConcatWithPrefix(args, '-l', opts.libs);

  if (opts.args) {
    args = args.concat(opts.args);
  }

  runTool('c++', outfile, args, opts, {maxBuffer: 500 * 1024}, callback);
}

function finalize(infile, outfile, opts, callback) {
  var args = [infile, '-o', outfile];
  opts = clone(opts) || {};

  if (opts.compress) {
    args.push('--compress');
  }

  if (opts.args) {
    args = args.concat(opts.args);
  }

  runTool('finalize', outfile, args, opts, {}, callback);
}

function translate(infile, outfile, opts, callback) {
  var args = [infile, '-o', outfile];
  opts = clone(opts) || {};

  if (opts.arch) {
    args.push('-arch');
    args.push(opts.arch);
  }

  if (opts.opt) {
    args.push('-O' + opts.opt);
  }

  if (opts.args) {
    args = args.concat(opts.args);
  }

  runTool('translate', outfile, args, opts, {}, callback);
}

function strip(infile, outfile, opts, callback) {
  var args = [infile];

  if (outfile) {
    args.push('-o');
    args.push(outfile);
  } else {
    outfile = infile;
  }

  opts = clone(opts) || {};

  if (opts.args) {
    args = args.concat(opts.args);
  }

  runTool('strip', outfile, args, opts, {}, callback);
}

function createNmf(infiles, outfile, opts, callback) {
  var args = [createNmfPath, '-o', outfile].concat(infiles);
  opts = clone(opts) || {};

  if (opts.args) {
    args = args.concat(opts.args);
  }

  mkdirp(path.dirname(outfile), function(error) {
    if (error) {
      return callback(error);
    }

    execFile('python', args, function(error) {
      if (error) {
        return callback(error);
      }

      return callback(null, outfile);
    });
  });
}

function build(infiles, outname, opts, callback) {
  var arches = opts.arch ? [opts.arch] : defaultArches,

      outfileNexe = function(arch) {
        return path.join(opts.outdir, outname + '_' + arch + '.nexe');
      },

      outfileExt = function(ext) {
        return path.join(opts.outdir, outname + ext);
      },

      doCompilePnacl = function() {
        var copts = clone(opts.compile) || {};
        extendWithAll(copts, opts, ['toolchain', 'config', 'arch']);
        compile(infiles, outfileExt('.bc'), copts, function(error, outfile) {
          if (error) {
            return callback(error);
          }

          doFinalize(outfile);
        });
      },

      doFinalize = function(infile) {
        var fopts = clone(opts.finalize) || {};
        extendWith(fopts, opts, 'toolchain');
        finalize(infile, outfileExt('.pexe'), fopts, function(error, outfile) {
          if (error) {
            return callback(error);
          }

          if (opts.translate) {
            doTranslate(outfile);
          } else if (opts.createNmf) {
            doNmf(outfile);
          } else {
            callback(null, outfile);
          }
        });
      },

      doTranslate = function(infile) {
        var outfiles = [],
            pendingArches = arches.length;
        arches.forEach(function(arch) {
          var topts = clone(opts.translate) || {};
          extendWith(topts, opts, 'toolchain');
          topts.arch = arch;
          translate(infile, outfileNexe(arch), topts, function(error, outfile) {
            if (error) {
              return callback(error);
            }

            outfiles.push(outfile);
            if (--pendingArches === 0) {
              if (opts.createNmf) {
                doNmf(outfiles);
              } else {
                callback(null, outfiles);
              }
            }
          });
        });
      },

      doCompileNacl = function() {
        var outfiles = [],
            pendingArches = arches.length;
        arches.forEach(function(arch) {
          var copts = clone(opts.compile) || {};
          extendWithAll(copts, opts, ['toolchain', 'config']);
          copts.arch = arch;
          compile(infiles, outfileNexe(arch), copts, function(error, outfile) {
            var sopts,
                nexeReady = function(outfile) {
                  outfiles.push(outfile);
                  if (--pendingArches === 0) {
                    if (opts.createNmf) {
                      doNmf(outfiles);
                    } else {
                      callback(null, outfiles);
                    }
                  }
                };

            if (error) {
              return callback(error);
            }

            if (opts.strip) {
              sopts = clone(opts.strip) || {};
              extendWithAll(sopts, opts, ['toolchain']);
              sopts.arch = arch;
              strip(outfile, null, sopts, function(error, outfile) {
                if (error) {
                  return callback(error);
                }

                nexeReady(outfile);
              });
            } else {
              nexeReady(outfile);
            }
          });
        });
      },

      doNmf = function(infiles) {
        var nopts = clone(opts.createNmf) || {};
        createNmf(infiles, outfileExt('.nmf'), nopts, function(error, outfile) {
          if (error) {
            return callback(error);
          }

          callback(null, outfile);
        });
      };

  if (!opts.toolchain) {
    throw new Error('opts.toolchain must be set.');
  }

  if (!opts.outdir) {
    throw new Error('opts.outdir must be set.');
  }

  if (opts.toolchain === 'pnacl') {
    doCompilePnacl();
  } else {
    doCompileNacl();
  }
}

function run(nexe, args, callback) {
  var args = [selLdrPath, nexe, '--'].concat(args || []);
  execFile('python', args, function(error, stdout, stderr) {
    if (error) {
      callback(new Error(error.toString() + '\n' + stdout));
      return;
    }

    callback(null, stdout, stderr);
  });
}

module.exports = {
  getToolPath: getToolPath,
  compile: compile,
  finalize: finalize,
  translate: translate,
  strip: strip,
  createNmf: createNmf,
  build: build,
  run: run,
};
